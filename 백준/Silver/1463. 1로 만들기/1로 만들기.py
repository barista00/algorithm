n = int(input())

dp = [0] * (n + 1)

for i in range(2, n + 1):
    dp[i] = dp[i-1] + 1 # 1은 최종결과니까 0시작 2는 비용1, 10은 비용9가 되는 +1 연산을 한다 
    # +1 연산과 2배수 3배수를 구해 최소비용을 구한다 min()
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i//2] + 1) # i가 4라면 현재 dp[4]값이 3이고 나누기2인 dp[4//2]는 1이기 때문에 1+1의 2가 최소비용이 된다
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3] + 1) # 3의 배수로도 똑같은 원리로 만들어준다
    # 만약 n이 10인 경우라면 2의 배수로 최적화시키면 10의 비용은 2의배수 최대인 8의 비용은 3, 9는 4, 10은 5로 최적화되어있는 상황이다
    # 3의 배수가 개입하면 9의 비용은 2로 최적화되기 때문에 최종적으로 +1으 한 3이 완성된다
print(dp[n]) # 알아서 최적화 되므로 dp에 input받은 n인덱스값을 출력하면 답이다
